#mysql 事务隔离级别
> 在DBMS中，事务保证了一个操作序列可以全部都执行或者全部都不执行（原子性），

>从一个状态转变到另外一个状态（一致性）。

> 由于事务满足持久性（持久性）。所以一旦事务被提交之后，数据就能够被持久化下来，又因为事务是满足隔离性的，所以，当多个事务同时处理同一个数据的时候，多个事务直接是互不影响的，
所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生脏读、不可重复读或者幻读等读现象。

> 事务隔离级别体现在自动加锁机智上;

> 部分关联到 锁的知识

[关于redo日志](https://blog.csdn.net/linuxheik/article/details/62043450)

隔离级别总类
------------------

1. 有4总隔离级别：

+ 未提交读(Read uncommitted 或者说RU级别)、

+ 提交读(Read committed或者说RC级别)、

+ 可重复读(Repeatable reads 或者说RR级别 mysql 默认级别)、

+ 可序列化(Serializable)。

未提交读(Read uncommitted)
---------------------------------------
> 未提交读级别，对事务限制少，但会产生 脏读 不可重复读 幻读
+ 概念

> 未提交读的数据库锁情况（实现原理）
  事务在修改数据的时候只对数据增加行级共享锁。

+ 现象

> 事务1读取某行记录时，事务2也能对这行记录进行读取、更新（因为事务一并未对数据增加任何锁）

> 当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本（因为事务二只增加了共享读锁，事务一可以再增加共享读锁读取数据），即使该修改尚未被提交。

> 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（因为事务一对数据增加了共享读锁，事务二不能增加排他写锁进行数据的修改）

提交读(Read committed)
-------------------------------

> rc 级别可以防止脏读，但是不可以能解决不可重复读 和 脏读的问题。

+ 概念

> 事务在更新某数据的时候就会自动加行级排它锁，直到事务结束。

+ 现象

> 事务1更新某行记录时，事务2不可能对这该记录做更新和读取，直到事务1结束。

> 事务1和事务2同时读取该行数据，事务1修改更新后 提交事务，事务2再次读取数据就是更新后的数据（不可重复读 2次读取内容不一样）。

可重复读(Repeatable reads) 
-------------------------------
> mysql 事务默认级别,避免了脏读和不可重复重复读，但不能有效避免幻读。

+ 概念

> 事务在读取某数据只是快照读（redo 日志 记录），（事务总会读取事务开始时候的值）不会上锁。

> 事务在更新某数据的瞬间, 加行级排他锁，直到事务结束才释放

+ 现象

> 事务1在读取某行记录的整个过程中，事务2都可以对该行记录读取（快照读）。

> 事务1在更新某行记录的整个过程中，事务2都不能修改该行数据。(排它锁)

> 事务1更新完后，事务2查询结果还是第一次查询的结果（开始时候的快照）。

可序列化(Serializable)
------------------------  

+ 概念

> 事务在读取数据时，加行级共享锁 ，直到事务结束才释放；

> 事务在更新数据时，加行级排他锁 ，直到事务结束才释放。

+ 象限

> 事务1在读取某行记录的，则事务2也能读取该行，
  但不能对这一行更新、新增、删除，直到事务1结束。（死锁 互斥）

> 无法insert 新增数据 防止里幻读。（gay锁）

