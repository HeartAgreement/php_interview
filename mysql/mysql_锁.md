#mysql 锁
>这里只有说明 innodb 7种锁 ：

1.Shared and Exclusive Locks  (排它锁 X Lock 和共享锁 S Lock)
2. Intention Locks (意向锁: 意向锁写 IX 和 意向锁读 IS)
3. Record Locks 记录锁（其实就是行锁）
4. Gap Locks （间隙锁）
5. Next-Key Locks （下一个键锁）
6. Insert Intention Locks (插入意向锁)
7. AUTO-INC Locks (自增插入锁)
8. Predicate Locks for Spatial Indexes 特殊自行官方手册

> 行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key（主键索引）（行锁就是 排它锁（写锁）或 共享锁（读锁））。

>  Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。

排它锁（写锁）与 共享锁（读锁）
------------------------------
> 快照读：简单的select操作，属于快照读。(当然，也有例外 rr级别以下都是当前读，针对事务)。

> 快照读：快照读第一次读取内容时候就写进 redo 日志进行记录，事务未提交每次读的都是快照（无论源数据是否改变）。

> 当前读：特殊的读操作，插入/更新/删除操作，属于当前读（读取最新版本）.

> mysql默认事务隔离级别是 RR 级别，默认select 是快照读（有些时候需要 select 上排它锁，或者不读更新）update delete insert自动上排它锁

#### 1. 排它锁 

> 表级锁一样的道理

+ 概念 

> 一旦一行数据(或者表)被加上写锁，其他请求无法在对该行数据加读锁和写锁。（堵塞）

+ 语句

> 在查询语句后面增加 **FOR UPDATE** ,Mysql 会对查询结果中的每一行都加上排它锁，
其他线程对着写进行申请排它锁或者共享锁，阻塞等待。

```sql
SELECT ... FOR UPDATE;
```

#### 2. 共享锁

> 表级锁一样的道理

+ 概念 

> 共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数
据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。

> **注意：** 共享可以重复添加，如果要加排它锁要释放所有共享锁(该行记录所有共享锁)。这样会造成死锁（当两个事务
同时上共享锁后都进行写的操作，由于无法释放全部的共享锁会造成死锁）。

+ 语句

> 在查询语句后面增加 **LOCK IN SHARE MODE**，Mysql会对查询结果中的每行都加共享锁，
当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。
其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

```sql
SELECT .... LOCK IN SHARE MODE;
```

#### 3. 意向锁（意向共享锁 意向排他锁 ）

+ 概念

>意向锁是表级锁，意向锁为了方便检测表级锁和行级锁之间的冲突，
故在给一行记录加锁前，首先给该表加意向锁。也就是同时加意向锁和行级锁

>InnoDB中的两个表锁：
意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁
意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。
```sql
SELECT .... LOCK IN SHARE MODE;
SELECT ... FOR UPDATE;
//先上意向锁（意向共享锁 意向排他锁 ） 在上 排它锁 或者共享锁
```

+ 兼容图

|        | X    |  IX  | S   | IS  |
| ---    | ---: | ---: | ---:| ---:|
| X      | 冲突  |冲突  |冲突  |冲突  |
| IX     | 冲突  |兼容  |冲突  |兼容  |
| S      | 冲突  |冲突  |兼容  |兼容  |
| IS     | 冲突  |兼容  |兼容  |兼容  |

#### 4. gap锁（间隙锁）


+ 概念

>（是事务级别rr级别以上）防止幻读。通过锁阻止特定条件的新记录的插入，因为插入时也要获取gap锁

> 如果id未编入索引或具有非唯一索引，则该语句会锁定前一个间隙。

> 间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。

> 这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。

> 记录锁和间隙锁的结合，对于InnoDB中，更新非唯一索引对应的记录，
会加上Next-Key Lock。如果更新记录为空，就不能加记录锁，只能加间隙锁。

+ 例如：

```sql
//数据库结构
/**
主键     普通索引
  id    number
  1       1
  2       2
   .....
  5       5
**/
//SELECT ... where number between 1 and 5 FOR UPDATE;  //假如得到5条数据
//insert ... values(2) //会得到6条数据
//SELECT ... where number between 1 and 5 FOR UPDATE;  //假如得到5条数据
//这里就涉及到主键和索引的问题 gap是加载主键上的 gap锁住了id(1,5)的数据
SELECT ... where id =1  FOR UPDATE; //不会有gap锁

```
#### 5. 下一个键锁 Next-KeyLock

+ 概念

> 索引记录上的记录锁定和索引记录之前的间隙上的间隙锁定的组合。

>假设索引包含值10,11,13和20.此索引的可能的下一个键锁定包括以下间隔，其中圆括号表示排除间隔端点，方括号表示包含端点：
```
 (negative infinity, 10]
 (10, 11]
 (11, 13]
 (13, 20]
 (20, positive infinity)
```
#### 6. Insert Intention Locks (插入意向锁)
    
+ 概念

> 一个事务以将记录插入间隙(gap)。该事务在等待获取排它锁时采用插入意向锁

> 就是锁事务可以插入gap锁锁住的范围

```
// 例子:
1. 假如事务1 SELECT ... where number between 1 and 5 FOR UPDATE;
2. gap（间隙锁会锁住）1到5 这个间隙 不允许插入 
3. 事务2 INSERT INTO .... (id) VALUES (4); 
//获取排它锁时采用插入意图锁
//可以不冲突（不堵塞）插入
```

#### 7. AUTO-INC Locks (自增插入锁)

+ 概念

> RR级默认没有开启

> 一个AUTO-INC Locks是通过交易将与表中取得一个特殊的表级锁 AUTO_INCREMENT列。在最简单的情况下，
如果一个事务正在向表中插入值，则任何其他事务必须等待对该表执行自己的插入，以便第一个事务插入的行接收连续的主键值。

> 该innodb_autoinc_lock_mode 配置选项控制用于自动增加锁定的算法。
> 它允许您选择如何在可预测的自动增量值序列和插入操作的最大并发之间进行权衡。


总结
--------------------

1.  主键索引有record lock。

2.  唯一辅助索引有record lock。

3.  非唯一辅助索引有next-key lock。

4.  没有索引的话，则是全表范围的next-key lock。

5.  RC下只有record lock。

6.  RR&innodb_locks_unsafe_for_binlog=1，只有record lock。

有一部分涉及到事务隔离级别。
