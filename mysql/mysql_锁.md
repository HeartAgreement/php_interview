#mysql 锁
>这里只有说明 行锁（Record Lock）、排它锁（写锁 X Lock）、共享锁（读锁 S Lock）、意向锁、gap锁（间隙锁）和Next-Key Lock

> 注：这里锁信息是innodb  主要是 行锁（排它锁，共享锁） 、 gay锁 、 意向锁 、 Next-Key Lock.

> 行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key（主键索引）（行锁就是 排它锁（写锁）或 共享锁（读锁））。

>  Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。

排它锁（写锁）与 共享锁（读锁）
------------------------------
> 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外)

> 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁.

> mysql默认事务隔离级别是 RR 级别，默认select 是快照读（最好声明select 上排它锁）update delete insert上排它锁


#### 1.排它锁

+ 概念 

> 一旦数据表被加上写锁，其他请求无法在对该表增加读锁和写锁。


+ 语句

> 在查询语句后面增加 **FOR UPDATE** ,Mysql 会对查询结果中的每一行都加上排它锁，
其他线程对着写进行申请排它锁或者共享锁，阻塞等待。

```sql
SELECT ... FOR UPDATE;
```

#### 2.共享锁

+ 概念 

> 共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数
据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。

> **注意：** 共享可以重复添加，如果要加排它锁要释放所有共享锁。这样会造成死锁（当两个事务
同时上共享锁后都进行写的操作，由于无法释放全部的共享锁会造成死锁）。

+ 语句

> 在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，
当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。
其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

```sql
SELECT .... LOCK IN SHARE MODE;
```

#### 3.意向锁（意向共享锁 意向排他锁 innodb）

+ 概念

>意向锁是表级锁，意向锁为了方便检测表级锁和行级锁之间的冲突，
故在给一行记录加锁前，首先给该表加意向锁。也就是同时加意向锁和行级锁

>InnoDB中的两个表锁：
意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁
意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

#### 4.gap锁（间隙锁）和Next-Key Lock


+ 概念

>（是事务级别rr级别以上）防止幻读。通过锁阻止特定条件的新记录的插入，因为插入时也要获取gap锁

> 间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。

> 这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。

> 记录锁和间隙锁的结合，对于InnoDB中，更新非唯一索引对应的记录，
会加上Next-Key Lock。如果更新记录为空，就不能加记录锁，只能加间隙锁。

+ 例如：

```sql
SELECT ... where id > 5 FOR UPDATE; //gap就会锁住一个范围 (5,无尽大) (数据库只有1-5条数据,堵塞insert添加数据)
//当然这不是完全的防止幻读的
//数据库结构
/**
主键     普通索引
  id    number
  1       1
  2       2
   .....
  5       5
**/
//SELECT ... where number between 1 and 5 FOR UPDATE;  //假如得到5条数据
//insert ... values(2) //会得到6条数据
//SELECT ... where number between 1 and 5 FOR UPDATE;  //假如得到5条数据
//这里就涉及到主键和索引的问题 gay是加载主键上的 gay锁住了id(1,5)的数据
SELECT ... where id =1  FOR UPDATE; //gap就会锁住一个范围 (1,1)

```

总结
--------------------

1.  主键索引有record lock。

2.  唯一辅助索引有record lock。

3.  非唯一辅助索引有next-key lock。

4.  没有索引的话，则是全表范围的next-key lock。

5.  RC下只有record lock。

6.  RR&innodb_locks_unsafe_for_binlog=1，只有record lock。

有一部分涉及到事务隔离级别。
