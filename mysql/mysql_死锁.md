#mysql 死锁

### 一、死锁的条件：

1. 互斥条件：简单的说就是进程抢夺的资源必须是临界资源，一段时间内，该资源只能同时被一个进程所占有。

2. 请求和保持条件：当一个进程持有了一个（或者更多）资源，申请另外的资源的时候发现申请的资源被其他进程所持有，当前进程阻塞，但不会是放自己所持有的资源。

3. 不可抢占条件：进程已经获得的资源在未使用完毕的情况下不可被其他进程所抢占
    3. 在很多情况下这些条件都是合乎要求的。例如，为确保结果的一致性和数据库的完整性，互斥是非常有必要的。同理，不能随意的进行资源抢占。比如，当涉及数据资源时，必须提供回滚恢复机制（rollback recovery machanism）以支持抢占资源，这样才能把进程和他的资源恢复到以前适当的状态，使得进程最终可以重复他的动作。

    3. 前三个条件都是死锁存在的必要条件，但不是充分条件。对死锁的产生还需要第四个条件：

4. 循环等待条件：存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。

    4. 这里所说的资源不仅包括硬件资源或者其他的资源，还包括锁，锁也是一种资源，锁的争用也会导致死锁。
    
### 二、死锁避免:

1. 一般来说给多条记录上锁 **顺序不一致** 可能产生。（例如事务1给（1,3,6）上锁，同时事务2给（6,3,1）。使用in可以解决）。
2. 尽量避免共享锁。需要的直接上排它锁。

### 三、处理死锁问题 或者 查看死锁
自行百度 或 google
----------

> 如果参数innodb_table_locks=1并且autocommit=0时，InnoDB会留意表的死锁，和MySQL层面的行级锁。另外，InnoDB不会检测MySQL的Lock Tables命令和其他存储引擎死锁。你应该设置innodb_lock_wait_timeout来解决这种情况。 
  innodb_lock_wait_timeout是Innodb放弃行级锁的超时时间。
    
    